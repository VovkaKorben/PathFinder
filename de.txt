Барин, раз ты решил оставить весь «мозг» в DLL, это значительно упрощает жизнь скрипту — он действительно становится просто твоими «руками и ногами».

Вот как я вижу развернутый логический флоу твоего конечного автомата внутри DLL. Это архитектурная схема того, как global_action_index управляет сегментами.

Архитектурный сценарий (Псевдокод логики)
Представим, что у нас есть основная функция, которую бот вызывает каждый цикл (Tick). Назовём её GetNextStep.

Глобальные переменные состояния в DLL:

ScenarioStatus: текущая фаза сценария (например: 0 — путь к NPC, 1 — разговор, 2 — путь назад).

CurrentSegment: тип действия (gaMove, gaNpc, gaDlg).

pctx: контекст с массивом steps для бега.

1. Обработка сценария global_action_index = 1 (например, 7 Signs)
Plaintext

ФУНКЦИЯ GetNextStep(текущие_координаты, текст_диалога):

    ВЫБОР ScenarioStatus:

        ФАЗА 0: "Идем к NPC"
            CurrentSegment = gaMove
            ЕСЛИ (путь в pctx пуст):
                Найти координаты NPC_ID в базе
                Вызвать DoAStar(текущие_координаты, координаты_NPC) -> заполнить pctx.steps
            
            ЕСЛИ (мы пришли в конечную точку пути):
                ScenarioStatus = 1  // Переходим к следующей фазе
                Очистить pctx.steps
                ВЕРНУТЬ "IDLE"
            ИНАЧЕ:
                ВЕРНУТЬ "MOVETO" + следующая точка из pctx.steps

        ФАЗА 1: "Взаимодействие с NPC"
            CurrentSegment = gaNpc
            ЕСЛИ (окно диалога НЕ открыто):
                ВЕРНУТЬ "INTERACT" + NPC_ID
            ЕСЛИ (окно диалога ПОЯВИЛОСЬ):
                ScenarioStatus = 2 // Переходим к диалогу
                ВЕРНУТЬ "IDLE"

        ФАЗА 2: "Работа с диалогом"
            CurrentSegment = gaDlg
            РезультатАнализа = АнализироватьТекст(текст_диалога)
            
            ЕСЛИ (РезультатАнализа == "Нужно нажать Кнопку 1"):
                ВЕРНУТЬ "CLICK_DLG" + ID_кнопки
            ЕСЛИ (РезультатАнализа == "Диалог окончен / Квест взят"):
                ScenarioStatus = 3 // Идем дальше по сценарию
                ВЕРНУТЬ "CLOSE_DLG"
Как это работает для Барина:
Сегментация: Заметь, что gaMove здесь — это не весь сценарий, а только «транспортная подзадача». Как только транспортная задача решена (пришли к NPC), автомат переключает CurrentSegment на работу с объектом (gaNpc).

Реактивность: Если в фазе gaDlg NPC «отморозился» и не выдал квест (например, инвентарь полон), автомат увидит это в тексте диалога и может либо повторить попытку, либо аварийно переключиться на сегмент возврата в город.

Использование панелей: Состояние чекбоксов на твоей панели pan7Signs будет напрямую влиять на АнализироватьТекст. Например:

Если CheckBox1.Checked (сдавать камни) — ищем в диалоге слово «Seal Stones».

Если нет — ищем слово «Quest».

Почему это «пуленепробиваемо»:
Скрипт просто спрашивает: «Что мне делать?».

DLL отвечает: MOVETO(X,Y,Z). Скрипт идет.

DLL отвечает: INTERACT(NPC_ID). Скрипт кликает на NPC.

DLL отвечает: SELECT_DIALOG(5). Скрипт жмет пятую строчку.

Весь контроль за тем, почему мы сейчас жмем кнопку или куда бежим, скрыт в ScenarioStatus внутри DLL.








step
step
step
.....
npc sel
npc dlg
dlg sel1 
dlg sel2
.....
step






{ uPathfinder.pas }
{
  function TPathContext.GenerateNextSegment: boolean;
  begin
  Result := True;
  SetLength(FFinalPath, 0); // ������ ������ ����� �������� ����� ��������� ������

  case FQuestGoal of

  // --- �������� 1: ����������� � 7 ������� ---
  qg7SignsReg:
  case FSegmentState of

  saIdle: // ��� 1: ����� ����� �� NPC
  begin
  AddSegment_Move(TargetNPC_Pos); // ��������� ����� "����"
  FSegmentState := saMoving; // ��������� ��� ������ ��� � ������ ��������
  end;

  saMoving: // ��� 2: ������, ���� ����������
  begin
  AddSegment_Talk(TargetNPC_ID); // ��������� ����� "��������"
  FSegmentState := saTalking;
  FWaitState := stWaiting; // DLL ��������, ��� HTML �� �������
  end;

  saParsing: // ��� 3: ����������� ��, ��� ������� ������
  begin
  if AnalyzeHTML('Already Registered') then
  AddSegment_Message('Master, you are already in!') // ����� "���������"
  else
  AddSegment_Click(Bypass_Reg); // ����� "���� �� ������"

  FSegmentState := saFinished;
  end;
  end;

  // --- �������� 2: ������ ����� (��������, ������ ���������) ---
  qgWarehouse:
  // ��� ����� ����� �� ���������, �� �� ������ "��������"
  // ��������: AddSegment_Move(Warehouse_Pos) -> AddSegment_Talk -> saParsing (����� ����)
  end;

  FCurrentStep := 0; // �������� ��������� ���������������� ������� � ������
  end;
}




{ TResultNode }
{
  procedure TResultNode.AssignAction(const npc_id, a0, a1: int32);
  begin
  act := 1;
  data0 := npc_id;
  data1 := a0;
  data2 := a1;
  end;

  procedure TResultNode.AssignFromPoint(const p: TPoint3D);
  begin
  act := 0;
  data0 := p.X;
  data1 := p.Y;
  data2 := p.Z;
  end;

  procedure TResultNode.CopyTo(var aa, ax, ay, az: int32);
  begin
  aa := act;
  ax := data0;
  ay := data1;
  az := data2;
  end; }
  


  {
  procedure TPathContext.Init;

  begin
  SetLength(gScore, graph_points_count);
  SetLength(fScore, graph_points_count);
  SetLength(CameFrom, graph_points_count);

  SetLength(OpenSet, graph_points_count);

  SetLength(OpenSetIndex, graph_points_count);

  end; }


  function GetNode(const Index: int32; var act, X, Y, Z: int32): boolean;
  function TPathContext.GetNode(const Index: int32; var act, X, Y, Z: int32): boolean;
begin
  { Result := (Index >= 0) and (Index < (PointCount + ActionCount));
    if Result then
    FFinalPath[index].CopyTo(act, X, Y, Z);
  }
end;


 {
      // 1. Вытягиваем ID целевой точки
      TargetID := Integer(Item.Data);

      // 2. Считаем расстояние от текущего положения до входа в граф
      StartID := FindNearestPoint(StartPos);
      if StartID <> -1 then
      DistToStart := StartPos.DistanceTo(graph_points[StartID])
      else
      begin
      Memo1.Lines.Add('[lvWaypointsSelectItem] StartID = -1');
      Exit;
      end;

      // 3. Строим путь
      setlength(steps, 0);
      pi := DoAStar(steps, graph_points[StartID], graph_points[TargetID]);

      // Вывод информации
      Memo1.Lines.Add('=== ROUTE INFO ===');
      Memo1.Lines.Add(Format('From ID: %d to ID: %d', [StartID, TargetID]));
      Memo1.Lines.Add('-------------------');
      Memo1.Lines.Add(Format('Physical Distance: %.0f units', [pi.Distance]));
      Memo1.Lines.Add(Format('Total Path Cost:   %.0f (inc. weights)', [pi.TotalCost]));
      Memo1.Lines.Add('-------------------');
      Memo1.Lines.Add(Format('Nodes in Path: %d', [pi.PointCount]));
      Memo1.Lines.Add(Format('Actions found: %d', [pi.ActionCount]));
      Memo1.Lines.Add(Format('Entry distance: %.0f units', [DistToStart]));

      // TotalDist := 0;

      // 4. Вывод в Ваш Memo1

      { Memo1.Lines.Add(Format('S %d E %d', [StartID, TargetID]));

      Memo1.Lines.Add(Format('Total Path: %.0f units', [pctx^.Distance]));
      Memo1.Lines.Add(Format('Nodes: %d (Actions: %d)', [pctx^.PointCount, pctx^.ActionCount]));
      Memo1.Lines.Add(Format('Entry dist: %.0f units', [DistToStart]));

      if DistToStart > 1000 then
      Memo1.Lines.Add('!!! WARNING: Too far from entry point !!!');
    }



{
  procedure TWaypointForm.lvWaypointsSelectItem(Sender: TObject; Item: TListItem; Selected: Boolean);
  var

  TargetID, StartID: Integer;
  TotalDist, DistToStart: Double;
  NodeCount, ActionCount, i: Integer;
  X1, Y1, Z1, X2, Y2, Z2, Act: Integer;
  begin
  if (not Selected) or (Item = nil) then
  Exit;

  // 1. Вытягиваем ID точки из Data
  TargetID := Integer(Item.Data);

  // 2. Считаем расстояние до ближайшей «входной» точки графа
  StartID := GPathfinder.FindNearestPoint(current_point);
  if StartID <> -1 then
  DistToStart := GPathfinder.FPoints[StartID].DistanceTo(current_point)
  else
  DistToStart := 0;

  // 3. Просим штурмана построить путь для анализа
  NodeCount := GPathfinder.CalculateAStar(current_point, GPathfinder.FPoints[TargetID]);

  TotalDist := 0;
  ActionCount := 0;

  if NodeCount > 0 then
  begin
  for i := 0 to NodeCount - 1 do
  begin
  if GPathfinder.GetNode(i,Act, X1, Y1, Z1 ) then
  begin
  if Act <> 0 then
  Inc(ActionCount); // Считаем действия (экшены)
  if i > 0 then
  begin
  // Суммируем расстояние между текущей и предыдущей точкой пути
  GPathfinder.GetNode(i - 1,Act, X2, Y2, Z2 );
  TotalDist := TotalDist + Sqrt(Sqr(Int64(X1) - X2) + Sqr(Int64(Y1) - Y2) + Sqr(Int64(Z1) - Z2));
  end;
  end;
  end;
  end;

  // 4. Вывод в Ваш Memo1
  Memo1.Lines.Clear;
  Memo1.Lines.Add(Format('Destination: %s', [Item.Caption]));
  Memo1.Lines.Add(Format('Total Path: %.0f units', [TotalDist]));
  Memo1.Lines.Add(Format('Nodes: %d (Actions: %d)', [NodeCount, ActionCount]));
  Memo1.Lines.Add(Format('Entry dist: %.0f units', [DistToStart]));

  if DistToStart > 1000 then
  Memo1.Lines.Add('!!! WARNING: Too far from entry point !!!');
  end;
}



    { Memo2.Lines.BeginUpdate;
      try
      Memo2.Lines.Clear;
      if NearestID <> -1 then
      begin
      P := graph_points[NearestID];
      Dist := P.DistanceTo(StartPos);

      Memo2.Lines.Add(Format('Nearest point ID: %d', [NearestID]));
      Memo2.Lines.Add(Format('Distance: %.0f', [Dist]));
      Memo2.Lines.Add(Format('Pos: %d, %d, %d', [P.X, P.Y, P.Z]));

      link_count := length(graph_points[NearestID].Links);
      Memo2.Lines.Add(Format('Links count: %d', [link_count]));
      for i := 0 to link_count - 1 do
      Memo2.Lines.Add(Format('%d -> Link %d, Point %d, Dist: %f', [i, graph_points[NearestID].Links[i].ID, graph_points[NearestID].Links[i].TargetID, graph_points[NearestID].Links[i].Distance]));
      end
      else
      Memo2.Lines.Add('No points near');

      // Memo2.Lines.Add('-------------------');
      // Memo2.Lines.Add(''); // Отступ перед инфой о маршруте
      finally
      Memo2.Lines.EndUpdate;
      end; }